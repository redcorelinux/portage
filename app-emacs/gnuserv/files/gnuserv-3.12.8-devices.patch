Function device-class from devices.el is not used, but collides with
a function of the same name in frame.el of Emacs 29. So, inline what
we need, and drop devices.el altogether.

--- gnuserv-3.12.8/gnuserv-compat.el
+++ gnuserv-3.12.8/gnuserv-compat.el
@@ -153,9 +153,39 @@
 (if (string-match "XEmacs" (emacs-version))
     nil
 
-  (require 'devices)
   (defalias 'device-list 'frame-list)
   (defalias 'selected-device 'selected-frame)
+  (defalias 'device-live-p 'frame-live-p)
+  (defalias 'frame-device 'identity)
+  (defalias 'make-tty-device 'ignore)
+
+  (defun make-x-device (&optional display)
+    (if display
+	(make-frame-on-display display)
+      (make-frame)))
+
+  (defun device-on-window-system-p (&optional device)
+    "Return non-nil if DEVICE is on a window system.
+  This generally means that there is support for the mouse, the menubar,
+  the toolbar, glyphs, etc."
+    (and (cdr-safe (assq 'display (frame-parameters device))) t))
+
+  (defvar delete-device-hook nil
+    "Function or functions to call when a device is deleted.
+  One argument, the to-be-deleted device.")
+
+  (defun delete-device (device &optional force)
+    "Delete DEVICE, permanently eliminating it from use.
+  Normally, you cannot delete the last non-minibuffer-only frame (you must
+  use `save-buffers-kill-emacs' or `kill-emacs').  However, if optional
+  second argument FORCE is non-nil, you can delete the last frame. (This
+  will automatically call `save-buffers-kill-emacs'.)"
+    (let ((frames (device-frame-list device)))
+      (run-hook-with-args 'delete-device-hook device)
+      (while frames
+	(delete-frame (car frames) force)
+	(setq frames (cdr frames)))))
+
   (defun device-frame-list (&optional device)
     (list
      (if device
